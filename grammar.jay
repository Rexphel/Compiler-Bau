{-- Definition of global vars
%{
    Class MiniJavaParser {
        public static void main(String[] args) {
            System.out.println("Hello World!");
        }
    }
}%

%token LBRACE
%token RBRACE
%token LBRACKET
%token RBRACKET
%token NOT
%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE
%token ASSIGN
%token EQUAL
%token NOTEQUAL
%token GREATER
%token GREATEREQUAL
%token LESS
%token LESSEQUAL
%token IF
%token ELSE
%token WHILE
%token SEMICOLON
%token RETURN
%token BOOLEAN
%token INT
%token CHAR
%token STRING
%token NULLLITERAL
%token BOOLLITERAL
%token INTLITERAL
%token STRINGLITERAL
%token CLASS
%token NEW
%token SUPER
%token THIS
%token VOID
%token IDENTIFIER
%token EOF
%token DOT

%type <If> Ifthenstatement Ifthenelsestatement
%type <While> Whilestatement
%type <Block> Block
%type <LocalVarDecl> Localvardecleration
%type <Return> Returnstatement

%type <Assign> Assignment
%type <New> Newstmtexpr
%type <Methodcall> Methodcall
%type <Unary> Unary
%type <List<Statement>> Statements
%%

Block               : LBRACKET   RBRACKET { $$ = New Block(New ArrayList<Statement>())}
                    | LBRACKET  Statements  RBRACKET { $$ = New Block($2); }

Statement           : Ifthenstatement {$$ = $1;}  
                    | Ifthenelsestatement {$$ = $1;}
                    | Whilestatement {$$ = $1;}
                    | Block {$$ = $1;}
                    | emptystatement {$$ = $1;}
                    | returnstatement {$$ = $1;}
					| Stmtexprstmt {$$ = $1}

Expression          : SUPER {$$ = New Super($1);}
					| Localorfieldvar {$$ = $1;}
					| Instvar {$$ = $1;}
					| Unary {$$ = $1;}
					| Binary {$$ = $1;}
					| INTLITERAL {$$ = New JInteger($1);}
					| BOOLLITERAL {$$ = New JBoolean($1);}
					| CHARLITERAL {$$ = New JChar($1);}
					| STRINGLITERAL {$$ = New JString($1);} // ToDo: JString otr String?
					| NULLLITERAL {$$ = New JNull($1);}
					| Stmtexprexpr {$$ = $1}

Stmtexpr			: Assignment {$$ = $1;}
					| New {$$ = $1;}
					| Methodcall {$$ = $1;}
					


Localorfieldvar		: IDENTIFIER {$$ = New LocalOrFieldVar($1);}

Instvar				: Localorfieldvar DOT IDENTIFIER {$$ = New InstVar($1, $3);}

Unary				: Unaryoperator Expression {$$ = New Unary($1, $2);}

Unaryoperator		: NOT {$$ = $1;}
					: MINUS {$$ = $1;}
					: PLUS {$$ = $1;}

Binary				: Expression Binaryoperator Expression {$$ = New Binary($2, $1, $3);}

Binaryoperator		: PLUS {$$ = $1;}
					| MINUS {$$ = $1;}
					| MULTIPLY {$$ = $1;}
					| DIVIDE {$$ = $1;}
					| EQUAL {$$ = $1;}
					| NOTEQUAL {$$ = $1;}
					| GREATER {$$ = $1;}
					| GREATEREQUAL {$$ = $1;}
					| LESS {$$ = $1;}
					| LESSEQUAL {$$ = $1;}

Stmtexprexpr		: Stmtexpr {New StmtExprExpr($1);}

Stmtexprstmt		: Stmtexpr SEMICOLON {New StmtExprStmt($1);}

Assignment          : Localorfieldvar ASSIGN Expression { $$ = New Assignment($1, $3); }

New					: NEW Type LBRACKET Expressions RIGHTBRACKET { $$ = new New($2, $4); }

Expressions			: Expression {
						ArrayList<Expression> exprList = New ArrayList<>();
						exprList.add($1);
						$$ = exprList;
					  }
					| Expressions COMMA Expression {$1.add($2); $$ = $1;}

Methodcall			: Expression DOT IDENTIFIER LBRACKET Expressions RBRACKET {$$ = New MethodCall($1, $3, $5);}
					| IDENTIFIER LBRACKET Expressions RBRACKET {$$ = New MethodCall(new This(), $1, $3);}
                    
Statements          : Statement {
						ArrayList<Statement> stmtList = New ArrayList<>(); 
	      		  		stmtList.add($1);
			  			$$ = stmtList;
 					  }
                    | Statements Statement {$1.add($2); $$ = $1;}

Ifthenstatement     : IF LBRACKET Expression  RBRACKET  Statement {$$ = New ifStmt($3, $5, null);}

Ifthenelsestatement : IF LBRACKET Expression  RBRACKET Statement ELSE Statement  {$$ = New ifStmt($3, $5, new Statement($7));}

Whilestatement      : WHILE LBRACKET Expression  RBRACKET  Statement {$$ = New While($3, $5);}

Block               : LBRACKET   RBRACKET { $$ = new Block(new ArrayList<Statement>()) }
                    | LBRACKET  Statements  RBRACKET { $$ = new Block($2) }

Returnstatement     : RETURN SEMICOLON  { $$ = New Return(null) }
                    | RETURN Expression  SEMICOLON { $$ = New Return($2)}

Field            	: type IDENTIFIER SEMICOLON { $$ = new Field($2, $1, null);}
                    | type IDENTIFIER ASSIGN Expression SEMICOLON { $$ = new Field($2, $1, $4);}

Parameters         : parameters COMMA type IDENTIFIER { 
						paramMap = New HashMap<String, Type>();
						paramMap.putAll($1);
						paramMap.put($4, $3);
						$$ = paramMap;
					}
                    | type IDENTIFIER { 
						paramMap = New HashMap<String, Type>();
						paramMap.put($2, $1);
						$$ = paramMap;
					}

Method              : type IDENTIFIER LBRACE parameters RBRACE Block { 
						$$ = New Method($2, $1, $4, $6);
					}
					
// ToDo: Does Clazz Class need the whole Statement string?
Class               : CLASS IDENTIFIER LBRACKET RBRACKET { $$ = New Clazz("", New Type($2), New Field[]{}, New Method[]{}); }
                    | CLASS IDENTIFIER LREACKET VarsAndMethods RBRACKET { $$ = New Clazz("", New Type($2), $4.fieldDecl, $4.methodDecl); }

FieldsAndMethods      : FieldsAndMethods Field { 
						$$ = New Clazz(
							"", New Type(""), 
							New ArrayList<>($1.fieldDecl).add($2).toArray(New Field[$1.fieldDecl.length +1]),
							$1.methodDecl
						);
					}
                    | FieldsAndMethods Method { 
						$$ = New Clazz(
							"", New Type(""), 
							$1.fieldDecl ,
							New ArrayList<>($1.methodDecl).add($2).toArray(New Field[$1.methodDecl.length +1])
						);
					}
                    | Field { 
						$$ = New Clazz("", New Type(""), New Field[]{$1}, New Method[]{});
					}
                    | Method { 
						$$ = New Clazz("", New Type(""), New Field[]{}, New Method[]{$1});
					}

type				: VOID {$$ = new Type($1)}
					| BOOLEAN {$$ = new Type($1)}
					| CHAR {$$ = new Type($1)}
					| STRING {$$ = new Type($1)}
					| INT {$$ = new Type($1)}

%%
}