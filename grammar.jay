{-- Definition of global vars
%{
    class MiniJavaParser {
        public static void main(String[] args) {
            System.out.println("Hello World!");
        }
    }
}%

%token LBRACE
%token RBRACE
%token LBRACKET
%token RBRACKET
%token NOT
%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE
%token ASSIGN
%token EQUAL
%token NOTEQUAL
%token GREATER
%token GREATEREQUAL
%token LESS
%token LESSEQUAL
%token IF
%token ELSE
%token WHILE
%token SEMICOLON
%token RETURN
%token BOOLEAN
%token INT
%token CHAR
%token STRING
%token NULLLITERAL
%token BOOLLITERAL
%token INTLITERAL
%token STRINGLITERAL
%token CLASS
%token NEW
%token SUPER
%token THIS
%token VOID
%token IDENTIFIER
%token EOF
%%

statement           : ifthenstatement {$$ = $1;}  
                    | ifthenelsestatement {$$ = $1;}
                    | whilestatement {$$ = $1;}
                    | block {$$ = $1;}
                    | emptystatement {$$ = $1;}
                    | returnstatement {$$ = $1;}

expression          : SUPER {$$ = new Super($1);}
					| localorfieldvar {$$ = $1;}
					| instvar {$$ = $1;}
					| unary {$$ = $1;}
					| binary {$$ = $1;}
					| INTLITERAL {$$ = new Integer($1);}
					| BOOLLITERAL {$$ = new Boolean($1);}
					| CHARLITERAL {$$ = new Char($1);} //ToDo: Do we need a CHARLITERAL?
					| STRINGLITERAL {$$ = new String($1);}
					| JNULL {$$ = new JNull($1);}
					| stmtexprexpr

stmtexpr			: assignment {$$ = $1;}
					| new {$$ = $1;}
					| methodcall {$$ = $1;}


localorfieldvar		: IDENTIFIER {$$ = new LocalOrFieldVar($1);}

instvar				: localorfieldvar POINT IDENTIFIER {$$ = new InstVar($1, $3);} //ToDo: missing "." as token?

unary				: unaryoperator expression {$$ = new Unary($1, $2);}

unaryoperator		: NOT {$$ = $1;}
					: MINUS {$$ = $1;}
					: PLUS {$$ = $1;}

binary				: expression binaryoperator expression {$$ = new Binary($2, $1, $3);}

binaryoperator		: PLUS {$$ = $1;}
					| MINUS {$$ = $1;}
					| MULTIPLY {$$ = $1;}
					| DIVIDE {$$ = $1;}
					| EQUAL {$$ = $1;}
					| NOTEQUAL {$$ = $1;}
					| GREATER {$$ = $1;}
					| GREATEREQUAL {$$ = $1;}
					| LESS {$$ = $1;}
					| LESSEQUAL {$$ = $1;}

stmtexprexpr		: //ToDo: missing "." as token?

assignment          : localorfieldvar ASSIGN expression { $$ = new Assignment($1, $3); }

new					: NEW type LBRACKET expressions RIGHTBRACKET

expressions			: expression {
						ArrayList<Expression> exprList = new ArrayList<>();
						exprList.add($1);
						$$ = exprList;
					  }
					| expressions expression {$1.add($2); $$ = $1;}

methodcall			: IDENTIFIER LBRACKET expressions RBRACKET {$$ = new MethodCall(Optional.empty(), $1, $3);}
					| //ToDo: apparently MethodCall can also be called with an expression as parameter? localorfieldvar ASSIGN IDENTIFIER LBRACKET expressions RBRACKET {$$ = new MethodCall()}
                    






statements          : statement {
						ArrayList<Statement> stmtList = new ArrayList<>(); 
	      		  		stmtList.add($1);
			  			$$ = stmtList;
 					  }
                    | statements statement {$1.add($2); $$ = $1;}

ifthenstatement     : IF LBRACKET bexpression  RBRACKET  statement {$$ = new ifStmt($3, $5, Optional.empty());}

ifthenelsestatement : IF LBRACKET bexpression  RBRACKET statement ELSE statement  {$$ = new ifStmt($3, $5, Optional.of($7));}

whilestatement      : WHILE LBRACKET bexpression  RBRACKET  statement {$$ = new While($3, $5);}

block               : LBRACE   RBRACE {$$ = new Block(Optional.empty())}
                    | LBRACE  statements  RBRACE {$$ = new Block(Optional.of($2))}

emptystatement	    : SEMICOLON  { }

returnstatement     : RETURN SEMICOLON  {$$ = new Return(Optionl.empty())}
                    | RETURN expression  SEMICOLON {$$ = new Return(Optional.of($2))}








bexpression         : BOOLLITERAL { }  

field               : type name SEMICOLON { }
                    | type name EQUAL expression SEMICOLON { }

localVar            : type name SEMICOLON { }
                    | type name EQUAL expression SEMICOLON { }

variable            : localVar { }
                    | field { }

paramenters         : type name { }
                    | parameters COMMA type name { }

methodHead          : type name LBRACE  RBRACE { }
                    | type name LBRACE parameters RBRACE { }

methodBody          : LBRACKET RBRACKET { }
                    | LBRACKET block RBRACKET { }

method              : methodHead methodBody { }

extends             : EXTENDS name { }
                    | { }

implementations     : implementations name { }
                    | name { }

implements          : IMPLEMENTS implementations { }
                    | { }

classHead           : CLASS name { }
                    | CLASS name extends { }
                    | CLASS name extends implements { }

class               : CLASS name LBRACE methods RBRACE  { }
                    | CLASS name LBRACE RBRACE LBRACKET RBRACKET { }
                    | CLASS name LBRACE RBRACE LREACKET varsAndMethods RBRACKET { }

varsAndMethods      : varsAndMethods variable { }
                    | varsAndMethods method { }
                    | variable { }
                    | method { }

%%
}