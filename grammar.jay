{-- Definition of global vars
%{
    class MiniJavaParser {
        public static void main(String[] args) {
            System.out.println("Hello World!");
        }
    }
}%

%token LBRACE
%token RBRACE
%token LBRACKET
%token RBRACKET
%token NOT
%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE
%token ASSIGN
%token EQUAL
%token NOTEQUAL
%token GREATER
%token GREATEREQUAL
%token LESS
%token LESSEQUAL
%token IF
%token ELSE
%token WHILE
%token SEMICOLON
%token RETURN
%token BOOLEAN
%token INT
%token CHAR
%token STRING
%token NULLLITERAL
%token BOOLLITERAL
%token INTLITERAL
%token STRINGLITERAL
%token CLASS
%token NEW
%token SUPER
%token THIS
%token VOID
%token IDENTIFIER
%token EOF
%%

statement           : ifthenstatement {$$ = $1;}  
                    | ifthenelsestatement {$$ = $1;}
                    | whilestatement {$$ = $1;}
                    | block {$$ = $1;}
                    | emptystatement {$$ = $1;}
                    | returnstatement {$$ = $1;}
					| stmtexprstmt {$$ = $1}

expression          : SUPER {$$ = new Super($1);}
					| localorfieldvar {$$ = $1;}
					| instvar {$$ = $1;}
					| unary {$$ = $1;}
					| binary {$$ = $1;}
					| INTLITERAL {$$ = new JInteger($1);}
					| BOOLLITERAL {$$ = new JBoolean($1);}
					| CHARLITERAL {$$ = new JChar($1);}
					| STRINGLITERAL {$$ = new JString($1);} // ToDo: JString otr String?
					| NULLLITERAL {$$ = new JNull($1);}
					| stmtexprexpr

stmtexpr			: assignment {$$ = $1;}
					| new {$$ = $1;}
					| methodcall {$$ = $1;}
					


localorfieldvar		: IDENTIFIER {$$ = new LocalOrFieldVar($1);}

instvar				: localorfieldvar POINT IDENTIFIER {$$ = new InstVar($1, $3);}

unary				: unaryoperator expression {$$ = new Unary($1, $2);}

unaryoperator		: NOT {$$ = $1;}
					: MINUS {$$ = $1;}
					: PLUS {$$ = $1;}

binary				: expression binaryoperator expression {$$ = new Binary($2, $1, $3);}

binaryoperator		: PLUS {$$ = $1;}
					| MINUS {$$ = $1;}
					| MULTIPLY {$$ = $1;}
					| DIVIDE {$$ = $1;}
					| EQUAL {$$ = $1;}
					| NOTEQUAL {$$ = $1;}
					| GREATER {$$ = $1;}
					| GREATEREQUAL {$$ = $1;}
					| LESS {$$ = $1;}
					| LESSEQUAL {$$ = $1;}

stmtexprexpr		: stmtexpr {new StmtExprExpr($1);}

stmtexprstmt		: stmtexpr SEMICOLON {new StmtExprStmt($1);}

assignment          : localorfieldvar ASSIGN expression { $$ = new Assignment($1, $3); }

new					: NEW type LBRACKET expressions RIGHTBRACKET

expressions			: expression {
						ArrayList<Expression> exprList = new ArrayList<>();
						exprList.add($1);
						$$ = exprList;
					  }
					| expressions COMMA expression {$1.add($2); $$ = $1;}

methodcall			: IDENTIFIER LBRACKET expressions RBRACKET {$$ = new MethodCall(Optional.empty(), $1, $3);}
                    
statements          : statement {
						ArrayList<Statement> stmtList = new ArrayList<>(); 
	      		  		stmtList.add($1);
			  			$$ = stmtList;
 					  }
                    | statements statement {$1.add($2); $$ = $1;}

ifthenstatement     : IF LBRACKET bexpression  RBRACKET  statement {$$ = new ifStmt($3, $5, Optional.empty());}

ifthenelsestatement : IF LBRACKET bexpression  RBRACKET statement ELSE statement  {$$ = new ifStmt($3, $5, Optional.of($7));}

whilestatement      : WHILE LBRACKET bexpression  RBRACKET  statement {$$ = new While($3, $5);}

block               : LBRACE   RBRACE {$$ = new Block(Optional.empty());}
                    | LBRACE  statements  RBRACE {$$ = new Block(Optional.of($2));}

emptystatement	    : SEMICOLON  { }

returnstatement     : RETURN SEMICOLON  {$$ = new Return(Optionl.empty());}
                    | RETURN expression  SEMICOLON {$$ = new Return(Optional.of($2));5}

bexpression         : BOOLLITERAL { }  

variable            : type name SEMICOLON { }
                    | type name EQUAL expression SEMICOLON { }

paramenters         : parameters COMMA type name { 
						paramMap = new HashMap<String, Type>();
						paramMap.putAll($1);
						paramMap.put($4, $3);
						$$ = paramMap;
					}
                    | type name { 
						paramMap = new HashMap<String, Type>();
						paramMap.put($2, $1);
						$$ = paramMap;
					}

method              : type name LBRACE parameters RBRACE block { 
						$$ = new Method($2, $1, $4, $6);
					}

// ToDo: Does Clazz class need the whole statement string?
class               : CLASS name LBRACKET RBRACKET { $$ = new Clazz("", new Type($2), new Field[]{}, new Method[]{}); }
                    | CLASS name LREACKET varsAndMethods RBRACKET { $$ = new Clazz("", new Type($2), $4.fieldDecl, $4.methodDecl); }

varsAndMethods      : varsAndMethods variable { 
						$$ = new Clazz(
							"", new Type(""), 
							new ArrayList<>($1.fieldDecl).add($2).toArray(new Field[$1.fieldDecl.length +1]),
							$1.methodDecl
						);
					}
                    | varsAndMethods method { 
						$$ = new Clazz(
							"", new Type(""), 
							$1.fieldDecl ,
							new ArrayList<>($1.methodDecl).add($2).toArray(new Field[$1.methodDecl.length +1])
						);
					}
                    | variable { 
						$$ = new Clazz("", new Type(""), new Field[]{$1}, new Method[]{});
					}
                    | method { 
						$$ = new Clazz("", new Type(""), new Field[]{}, new Method[]{$1});
					}
%%
}